# Inspired from:
# - https://github.com/cockroachdb/sqlalchemy-cockroachdb/blob/master/.github/workflows/ci.yml
# - https://github.com/rgeo/activerecord-postgis-adapter/blob/master/.github/workflows/tests.yml
name: Test

on:
  push:
    branches: [master]
  # Triggers the workflow on pull request events.
  pull_request:
    types: [opened, reopened, synchronize]
  schedule:
    - cron: 12 13 * * 1 # Weekly
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# This allows a subsequently queued workflow run to interrupt previous runs.
concurrency:
  group: "${{ github.workflow }} @ ${{ github.ref }}"
  cancel-in-progress: true

jobs:
  orchestrate:
    runs-on: ubuntu-latest
    name: Prepare Tests
    outputs:
      supported_crdbs: ${{ steps.crdb.outputs.crdbs }}
      latest_crdb: ${{ steps.crdb.outputs.latest }}
    steps:
      - id: crdb
        name: Determine Supported CockroachDB Versions
        shell: ruby -rcsv -rjson -rnet/http -ruri {0}
        run: |
          link = "https://raw.githubusercontent.com/cockroachdb/docs/7c75d7596ae144c30f341b5b337b5775088f29df/src/current/_data/versions.csv"

          uri = URI.parse(link)
          data = Net::HTTP.get(uri)
          csv = CSV.parse(data, headers: true)

          versions = csv.filter_map do |row|
            support = row["asst_supp_exp_date"]
            support = row["maint_supp_exp_date"] if support == "N/A"

            row["major_version"] if Date.parse(support) >= Date.today
          end

          File.write(ENV["GITHUB_OUTPUT"], "crdbs=#{JSON.generate(versions)}\n", mode: ?a)
          File.write(ENV["GITHUB_OUTPUT"], "latest=#{JSON.generate(versions.max)}\n", mode: ?a)

          puts File.read(ENV["GITHUB_OUTPUT"])

  test:
    runs-on: ubuntu-latest
    needs: orchestrate
    continue-on-error: ${{ matrix.experimental }}
    strategy:
      fail-fast: false
      matrix:
        # https://www.cockroachlabs.com/docs/releases/release-support-policy
        crdb: ${{ fromJSON(needs.orchestrate.outputs.supported_crdbs) }}
        ruby: ["3.4"]
        rails: ["8-1-stable"]
        experimental: [false]
        include:
          - crdb: ${{ fromJSON(needs.orchestrate.outputs.latest_crdb) }}
            ruby: "3.4"
            rails: "main"
            experimental: true
    name: Test (crdb=${{ matrix.crdb }} ruby=${{ matrix.ruby }} rails=${{ matrix.rails }})
    steps:
      - name: Set Up Actions
        uses: actions/checkout@v4
      - uses: ./.github/actions/test-runner
        id: test
        with:
          crdb: ${{ matrix.crdb }}
          ruby: ${{ matrix.ruby }}
        env:
          RAILS_TAG: ${{ matrix.rails }}
          JSON_REPORTER: "report.json"
      - name: Upload Report
        if: ${{ failure() && steps.test.conclusion == 'failure' }}
        uses: actions/upload-artifact@v4
        with:
          name: report-${{ matrix.crdb }}-${{ matrix.ruby }}-{{ matrix.rails }}
          path: report.json
  # Since the name of the matrix job depends on the
  # version, we define another job with a more stable
  # name. We also aggregate failed tests to display
  # in the Github Summary.
  test_results:
    if: ${{ always() }}
    runs-on: ubuntu-latest
    name: Test Results
    needs: [test]
    steps:
      - name: Check Success
        run: |
          result="${{ needs.test.result }}"

          if [[ $result == "success" || $result == "skipped" ]]; then
            echo "All tests passed :taco:" >>$GITHUB_STEP_SUMMARY
            exit 0
          else
            exit 1
          fi
      - name: Download Reports
        if: failure()
        uses: actions/download-artifact@v4
        with:
          path: reports
      - name: Aggregate Reports
        if: failure()
        run: |
          cat <<EOF >>$GITHUB_STEP_SUMMARY
          # Failing Tests

          <table>
          <thead>
            <tr>
              <th>#</th>
              <th>Test</th>
              <th>Failure</th>
            </tr>
          </thead>
          <tbody>
          EOF

          jq --slurp --raw-output '
            map(.failed_tests) | flatten | map({
              klass,
              NAME,
              failure: .failures[0],
              source_url: (
                .source_location | if (.[0] | contains("/gems/")) then
                  (.[0] | capture("rails-(?<sha>.*?)/(?<path>.*)")) *
                  {line: .[1], server: "https://github.com", repo: "rails/rails"}
                else
                  (.[0] | capture("activerecord-cockroachdb-adapter/(?<path>test/.*)") *
                  {line: .[1], sha: $ENV.GITHUB_SHA, repo: $ENV.GITHUB_REPOSITORY, server: $ENV.GITHUB_SERVER_URL}
                end | "\(.server)/\(.repo)/blob/\(.sha)/\(.path)#L\(.line)"
              )
            }) | group_by(.) | map(.[0] * { count: length }) | sort[0:100][]
            | "<tr>"
            +   "<td><strong>\(.count)</strong></td>"
            +   "<td><a href=\"\(.source_url)\">\(.klass)#\(.NAME)</a></td>"
            +   "<td><pre>\(.failure)</pre></td>"
            + "</tr>"
          ' reports/*/report.json >>$GITHUB_STEP_SUMMARY

          cat <<EOF >>$GITHUB_STEP_SUMMARY
          </tbody>
          </table>
          EOF

          # Do not print json if too large.
          [[ "$(du -s reports | cut -f1)" -gt 124 ]] && exit 0

          echo >>$GITHUB_STEP_SUMMARY
          echo '```json' >>$GITHUB_STEP_SUMMARY
          jq --slurp --compact-output '.' reports/*/report.json >>$GITHUB_STEP_SUMMARY
          echo '```' >>$GITHUB_STEP_SUMMARY
